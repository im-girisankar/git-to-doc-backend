export function generateMarkdown(data) {
  const { 
    repoInfo, 
    overview, 
    context, 
    readme, 
    files, 
    functions, 
    classes, 
    apiEndpoints,
    installInstructions,
    usageInstructions 
  } = data;

  let markdown = `# ${repoInfo.name}\n\n`;
  
  if (repoInfo.description) {
    markdown += `> ${repoInfo.description}\n\n`;
  }
  
  markdown += `**Language:** ${repoInfo.language} | **Stars:** ${repoInfo.stars} â­ | **Repository:** [${repoInfo.fullName}](https://github.com/${repoInfo.fullName})\n\n`;

  markdown += `---\n\n`;

  // Table of Contents
  markdown += `## ðŸ“‹ Table of Contents\n\n`;
  markdown += `- [Architecture Overview](#architecture-overview)\n`;
  if (context) markdown += `- [Project Context](#project-context)\n`;
  markdown += `- [Project Statistics](#project-statistics)\n`;
  if (installInstructions) markdown += `- [Installation](#installation)\n`;
  if (usageInstructions) markdown += `- [Usage](#usage)\n`;
  if (apiEndpoints.length > 0) markdown += `- [API Endpoints](#api-endpoints)\n`;
  if (functions.length > 0) markdown += `- [Core Functions](#core-functions)\n`;
  if (classes.length > 0) markdown += `- [Classes](#classes)\n`;
  markdown += `- [Project Structure](#project-structure)\n\n`;

  markdown += `---\n\n`;

  // Architecture Overview
  markdown += `## ðŸ—ï¸ Architecture Overview\n\n`;
  markdown += `${overview}\n\n`;

  // User Context
  if (context) {
    markdown += `## ðŸ“ Project Context\n\n`;
    markdown += `${context}\n\n`;
  }

  // Statistics
  markdown += `## ðŸ“Š Project Statistics\n\n`;
  markdown += `| Metric | Count |\n`;
  markdown += `|--------|-------|\n`;
  markdown += `| Files Analyzed | ${files.length} |\n`;
  markdown += `| Functions Found | ${functions.length} |\n`;
  markdown += `| Classes Found | ${classes.length} |\n`;
  markdown += `| API Endpoints | ${apiEndpoints.length} |\n\n`;

  // LLM-Generated Installation Instructions
  if (installInstructions) {
    markdown += `## ðŸš€ Installation\n\n`;
    markdown += `${installInstructions}\n\n`;
  } else if (readme) {
    // Fallback to README extraction
    markdown += `## ðŸš€ Installation\n\n`;
    const setupSection = extractSetupSection(readme);
    if (setupSection) {
      markdown += setupSection + '\n\n';
    } else {
      markdown += `Refer to the [repository README](https://github.com/${repoInfo.fullName}#readme) for installation instructions.\n\n`;
    }
  }

  // LLM-Generated Usage Instructions
  if (usageInstructions) {
    markdown += `## ðŸ“– Usage\n\n`;
    markdown += `${usageInstructions}\n\n`;
  } else if (readme) {
    // Fallback to README extraction
    const usageSection = extractUsageSection(readme);
    if (usageSection) {
      markdown += `## ðŸ“– Usage\n\n`;
      markdown += usageSection + '\n\n';
    }
  }

  // API Endpoints
  if (apiEndpoints.length > 0) {
    markdown += `## ðŸ”Œ API Endpoints\n\n`;
    apiEndpoints.forEach(endpoint => {
      markdown += `### \`${endpoint.method} ${endpoint.path}\`\n\n`;
      markdown += `- **File:** \`${endpoint.file}\`\n`;
      markdown += `- **Handler:** \`${endpoint.handler}\`\n\n`;
    });
  }

  // Core Functions
  if (functions.length > 0) {
    markdown += `## âš™ï¸ Core Functions\n\n`;
    functions.forEach(func => {
      markdown += `### \`${func.name}(${func.params.join(', ')})\`\n\n`;
      if (func.summary) {
        markdown += `${func.summary}\n\n`;
      }
      markdown += `**Type:** ${func.async ? 'Async' : 'Sync'} Function\n\n`;
      markdown += `<details>\n<summary>View Source Code</summary>\n\n`;
      
      // Determine language for syntax highlighting
      const language = determineLanguage(files);
      markdown += `\`\`\`${language}\n${func.code}\n\`\`\`\n\n`;
      markdown += `</details>\n\n`;
    });
  }

  // Classes
  if (classes.length > 0) {
    markdown += `## ðŸ›ï¸ Classes\n\n`;
    classes.forEach(cls => {
      markdown += `- **${cls.name}** (Line ${cls.lineStart})\n`;
    });
    markdown += `\n`;
  }

  // Project Structure
  markdown += `## ðŸ“ Project Structure\n\n`;
  markdown += `\`\`\`\n`;
  const fileTree = buildFileTree(files);
  markdown += fileTree;
  markdown += `\`\`\`\n\n`;

  // Contributing section (optional)
  if (readme && readme.toLowerCase().includes('contributing')) {
    markdown += `## ðŸ¤ Contributing\n\n`;
    markdown += `Contributions are welcome! Please refer to the [repository](https://github.com/${repoInfo.fullName}) for contribution guidelines.\n\n`;
  }

  // License (if available in repo info)
  if (repoInfo.license) {
    markdown += `## ðŸ“„ License\n\n`;
    markdown += `This project is licensed under the ${repoInfo.license}.\n\n`;
  }

  markdown += `---\n\n`;
  markdown += `*ðŸ“„ Generated by **CodeDocs AI** â€¢ ${new Date().toLocaleDateString()} â€¢ [Generate your own docs](https://github.com/your-username/codedocs-ai)*\n`;

  return markdown;
}

function extractSetupSection(readme) {
  // Try to find installation/setup section
  const sections = readme.split(/^##/m);
  for (const section of sections) {
    if (section.match(/install|setup|getting started|quick start/i)) {
      return '## ' + section.trim();
    }
  }
  return null;
}

function extractUsageSection(readme) {
  // Try to find usage/examples section
  const sections = readme.split(/^##/m);
  for (const section of sections) {
    if (section.match(/usage|example|how to use|running/i)) {
      return '## ' + section.trim();
    }
  }
  return null;
}

function determineLanguage(files) {
  // Determine primary language for code blocks
  if (!files || files.length === 0) return 'text';
  
  const languageCount = {};
  files.forEach(file => {
    const lang = file.language?.toLowerCase();
    if (lang) {
      languageCount[lang] = (languageCount[lang] || 0) + 1;
    }
  });

  // Get most common language
  const primaryLanguage = Object.entries(languageCount)
    .sort((a, b) => b[1] - a[1])[0]?.[0];

  // Map to syntax highlighting names
  const languageMap = {
    'javascript': 'javascript',
    'typescript': 'typescript',
    'python': 'python',
    'java': 'java',
    'go': 'go',
    'rust': 'rust',
    'ruby': 'ruby',
    'php': 'php',
    'c': 'c',
    'c++': 'cpp',
    'c#': 'csharp'
  };

  return languageMap[primaryLanguage] || primaryLanguage || 'text';
}

function buildFileTree(files) {
  if (!files || files.length === 0) return 'No files found';

  const tree = {};
  
  files.forEach(file => {
    const parts = file.path.split('/');
    let current = tree;
    
    parts.forEach((part, index) => {
      if (!current[part]) {
        current[part] = index === parts.length - 1 ? null : {};
      }
      if (current[part]) {
        current = current[part];
      }
    });
  });
  
  function printTree(node, prefix = '', isLast = true) {
    let result = '';
    const entries = Object.entries(node);
    
    entries.forEach(([key, value], index) => {
      const isLastEntry = index === entries.length - 1;
      const connector = isLastEntry ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
      const extension = prefix + connector;
      
      result += extension + key + '\n';
      
      if (value !== null) {
        const newPrefix = prefix + (isLastEntry ? '    ' : 'â”‚   ');
        result += printTree(value, newPrefix, isLastEntry);
      }
    });
    
    return result;
  }
  
  return printTree(tree);
}
